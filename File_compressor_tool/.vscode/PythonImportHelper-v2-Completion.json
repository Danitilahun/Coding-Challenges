[
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "process_file",
        "importPath": "src.utils.file_reader",
        "description": "src.utils.file_reader",
        "isExtraImport": true,
        "detail": "src.utils.file_reader",
        "documentation": {}
    },
    {
        "label": "process_file",
        "importPath": "src.utils.file_reader",
        "description": "src.utils.file_reader",
        "isExtraImport": true,
        "detail": "src.utils.file_reader",
        "documentation": {}
    },
    {
        "label": "calculate_character_frequency",
        "importPath": "src.utils.text_utils",
        "description": "src.utils.text_utils",
        "isExtraImport": true,
        "detail": "src.utils.text_utils",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "assert_that",
        "importPath": "hamcrest",
        "description": "hamcrest",
        "isExtraImport": true,
        "detail": "hamcrest",
        "documentation": {}
    },
    {
        "label": "equal_to",
        "importPath": "hamcrest",
        "description": "hamcrest",
        "isExtraImport": true,
        "detail": "hamcrest",
        "documentation": {}
    },
    {
        "label": "calling",
        "importPath": "hamcrest",
        "description": "hamcrest",
        "isExtraImport": true,
        "detail": "hamcrest",
        "documentation": {}
    },
    {
        "label": "raises",
        "importPath": "hamcrest",
        "description": "hamcrest",
        "isExtraImport": true,
        "detail": "hamcrest",
        "documentation": {}
    },
    {
        "label": "given",
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "isExtraImport": true,
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "then",
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "isExtraImport": true,
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "when",
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "isExtraImport": true,
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "prepare_file_system",
        "importPath": "tests.infrastructure.steps",
        "description": "tests.infrastructure.steps",
        "isExtraImport": true,
        "detail": "tests.infrastructure.steps",
        "documentation": {}
    },
    {
        "label": "create_invalid_file",
        "importPath": "tests.infrastructure.steps",
        "description": "tests.infrastructure.steps",
        "isExtraImport": true,
        "detail": "tests.infrastructure.steps",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "process_and_calculate",
        "importPath": "src.main_solution",
        "description": "src.main_solution",
        "isExtraImport": true,
        "detail": "src.main_solution",
        "documentation": {}
    },
    {
        "label": "HuffmanNode",
        "kind": 6,
        "importPath": "src.helpers.huffman_coding_trees",
        "description": "src.helpers.huffman_coding_trees",
        "peekOfCode": "class HuffmanNode:\n    def __init__(self, weight: int, element: Optional[str] = None, \n                 left: Optional['HuffmanNode'] = None, \n                 right: Optional['HuffmanNode'] = None):\n        \"\"\"\n        Constructor for a Huffman node.\n        :param weight: The weight (frequency) of the node.\n        :param element: The character element for this node (None for internal nodes).\n        :param left: Left child node (None for leaf nodes).\n        :param right: Right child node (None for leaf nodes).",
        "detail": "src.helpers.huffman_coding_trees",
        "documentation": {}
    },
    {
        "label": "HuffmanTree",
        "kind": 6,
        "importPath": "src.helpers.huffman_coding_trees",
        "description": "src.helpers.huffman_coding_trees",
        "peekOfCode": "class HuffmanTree:\n    def __init__(self, frequencies: Dict[str, int]):\n        \"\"\"\n        Initialize the Huffman tree with a frequency dictionary.\n        :param frequencies: A dictionary with characters as keys and their frequencies as values.\n        \"\"\"\n        self.frequencies: Dict[str, int] = frequencies\n        self.root: Optional[HuffmanNode] = None\n    def build_tree(self) -> None:\n        \"\"\"",
        "detail": "src.helpers.huffman_coding_trees",
        "documentation": {}
    },
    {
        "label": "process_file",
        "kind": 2,
        "importPath": "src.utils.file_reader",
        "description": "src.utils.file_reader",
        "peekOfCode": "def process_file(filename: str) -> str:\n    \"\"\"\n    Processes the input file. If invalid, raises appropriate exceptions.\n    Args:\n        filename (str): The name of the file to be processed.\n    Returns:\n        str: The content of the file.\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        IsADirectoryError: If the filename points to a directory instead of a file.",
        "detail": "src.utils.file_reader",
        "documentation": {}
    },
    {
        "label": "calculate_character_frequency",
        "kind": 2,
        "importPath": "src.utils.text_utils",
        "description": "src.utils.text_utils",
        "peekOfCode": "def calculate_character_frequency(text: str) -> dict:\n    \"\"\"\n    Calculates the frequency of each character in the given text.\n    Args:\n        text (str): The input text.\n    Returns:\n        dict: A dictionary where keys are characters and values are their respective frequencies.\n    \"\"\"\n    return dict(Counter(text))",
        "detail": "src.utils.text_utils",
        "documentation": {}
    },
    {
        "label": "process_and_calculate",
        "kind": 2,
        "importPath": "src.main_solution",
        "description": "src.main_solution",
        "peekOfCode": "def process_and_calculate(filename: str) -> dict:\n    \"\"\"\n    Processes a file and calculates the frequency of characters in its content.\n    Args:\n        filename (str): The name of the file.\n    Returns:\n        dict: A dictionary with character frequencies.\n    \"\"\"\n    # Step 1: Read the file content\n    content = process_file(filename)",
        "detail": "src.main_solution",
        "documentation": {}
    },
    {
        "label": "Context",
        "kind": 6,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "class Context:\n    def __getattribute__(self, name: str):\n        return object.__getattribute__(self, name)\nclass GivenScope:\n    def __init__(self, steps):\n        self.context = Context()\n        self.steps = steps or []\n        self.started_steps = []\n    def __enter__(self):\n        for step in self.steps:",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "GivenScope",
        "kind": 6,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "class GivenScope:\n    def __init__(self, steps):\n        self.context = Context()\n        self.steps = steps or []\n        self.started_steps = []\n    def __enter__(self):\n        for step in self.steps:\n            result = step(self.context)\n            self.started_steps.append(result)\n            if hasattr(result, '__enter__'):",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "MockWith",
        "kind": 6,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "class MockWith:\n    def __enter__(self):\n        pass\n    def __exit__(self, type, value, traceback):\n        pass\n    def __getattribute__(self, item):\n        return MockWith()\ndef given(steps=None):\n    return GivenScope(steps)\ndef then(message=None):",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "given",
        "kind": 2,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "def given(steps=None):\n    return GivenScope(steps)\ndef then(message=None):\n    return MockWith()\ndef when(description=None):\n    return MockWith()\ndef resulting(param=None):\n    return MockWith()",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "then",
        "kind": 2,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "def then(message=None):\n    return MockWith()\ndef when(description=None):\n    return MockWith()\ndef resulting(param=None):\n    return MockWith()",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "when",
        "kind": 2,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "def when(description=None):\n    return MockWith()\ndef resulting(param=None):\n    return MockWith()",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "resulting",
        "kind": 2,
        "importPath": "tests.infrastructure.givenpy",
        "description": "tests.infrastructure.givenpy",
        "peekOfCode": "def resulting(param=None):\n    return MockWith()",
        "detail": "tests.infrastructure.givenpy",
        "documentation": {}
    },
    {
        "label": "prepare_file_system",
        "kind": 2,
        "importPath": "tests.infrastructure.steps",
        "description": "tests.infrastructure.steps",
        "peekOfCode": "def prepare_file_system(valid_file_content=None, non_existent_file=False,\n                        directory_instead_of_file=False, unreadable_file=False):\n    \"\"\"\n    Step to set up file system states for testing.\n    \"\"\"\n    def step(context):\n        base_dir = Path(\"/tmp/test_process_file\")\n        base_dir.mkdir(parents=True, exist_ok=True)\n        if valid_file_content:\n            file_path = base_dir / \"valid_file.txt\"",
        "detail": "tests.infrastructure.steps",
        "documentation": {}
    },
    {
        "label": "create_invalid_file",
        "kind": 2,
        "importPath": "tests.infrastructure.steps",
        "description": "tests.infrastructure.steps",
        "peekOfCode": "def create_invalid_file():\n    \"\"\"\n    Step to create a deliberately invalid file for testing.\n    \"\"\"\n    def step(context):\n        base_dir = Path(\"/tmp/test_process_file\")\n        base_dir.mkdir(parents=True, exist_ok=True)\n        file_path = base_dir / \"invalid_file.txt\"\n        file_path.touch()\n        context.file_path = str(file_path)",
        "detail": "tests.infrastructure.steps",
        "documentation": {}
    },
    {
        "label": "ProcessFileTest",
        "kind": 6,
        "importPath": "tests.utils.test_process_file",
        "description": "tests.utils.test_process_file",
        "peekOfCode": "class ProcessFileTest(unittest.TestCase):\n    def test_that_valid_file_returns_content(self):\n        with given([\n            prepare_file_system(valid_file_content=\"Sample content\")\n        ]) as context:\n            file_path = cast(str, context.file_path)\n            with when():\n                content = process_file(file_path)\n            with then():\n                assert_that(content, equal_to(\"Sample content\"))",
        "detail": "tests.utils.test_process_file",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    if len(sys.argv) != 2:\n        print(\"Usage: python main.py <filename>\")\n        sys.exit(1)\n    filename = sys.argv[1]\n    absolute_path = os.path.abspath(filename)\n    try:\n        frequency = process_and_calculate(absolute_path)\n        print(\"Character Frequencies:\")\n        for char, freq in frequency.items():",
        "detail": "main",
        "documentation": {}
    }
]